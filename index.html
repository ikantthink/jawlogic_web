<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo v1.0.0</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
        }
        canvas {
            display: block;
        }
        #toolbar {
            height: 60px;
            background-color: #222;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            overflow-x: auto;
            white-space: nowrap;
        }
        #toolbar button {
            background-color: #111;
            color: white;
            border: none;
            border-radius: 8px;
            margin-right: 10px;
            padding: 10px 20px;
            cursor: pointer;
        }
        #tryForMonson {
            background-color: pink;
            color: white;
        }
        #container {
            width: 100%;
            height: calc(100vh - 60px);
            position: relative;
        }
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        .hidden {
            display: none;
        }
        #radiusLabel {
            position: absolute;
            top: 60px;
            left: 20px;
            color: white;
            background-color: #222;
            padding: 10px;
            border-radius: 8px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="loadModel">Load Model</button>
        <button id="viewTop" class="hidden">Top</button>
        <button id="viewRight" class="hidden">Right</button>
        <button id="viewLeft" class="hidden">Left</button>
        <button id="viewBottom" class="hidden">Bottom</button>
        <button id="viewFront" class="hidden">Front</button>
        <button id="viewBack" class="hidden">Back</button>
        <button id="centerModel" class="hidden">Center Model</button>
        <button id="tryForMonson" class="hidden">Try for Monson</button>
        <input type="file" id="fileInput" style="display: none;">
    </div>
    <div id="container">
        <div id="loadingIndicator">Loading...</div>
        <div id="radiusLabel">Radius: 0 mm</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/STLLoader.js"></script>
    <script>
        let container, camera, scene, renderer, controls;
        let stlLoader, mesh, monsonSphere, centerSphere;
        const X = 10;

        init();
        animate();

        function init() {
            container = document.getElementById('container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight - 60), 1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 60);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);

            // STL Loader
            stlLoader = new THREE.STLLoader();

            // Lights
            const ambientLight = new THREE.AmbientLight(0x555555);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff);
            directionalLight1.position.set(1, 1, 1).normalize();
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff);
            directionalLight2.position.set(-1, 1, -1).normalize();
            scene.add(directionalLight2);

            const directionalLight3 = new THREE.DirectionalLight(0xffffff);
            directionalLight3.position.set(1, -1, 1).normalize();
            scene.add(directionalLight3);

            const directionalLight4 = new THREE.DirectionalLight(0xffffff);
            directionalLight4.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight4);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(10 * X, 10, 0x222222, 0x222222);
            scene.add(gridHelper);

            // Event listeners
            document.getElementById('loadModel').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.getElementById('viewTop').addEventListener('click', () => setView('top'));
            document.getElementById('viewRight').addEventListener('click', () => setView('right'));
            document.getElementById('viewLeft').addEventListener('click', () => setView('left'));
            document.getElementById('viewBottom').addEventListener('click', () => setView('bottom'));
            document.getElementById('viewFront').addEventListener('click', () => setView('front'));
            document.getElementById('viewBack').addEventListener('click', () => setView('back'));
            document.getElementById('centerModel').addEventListener('click', centerModel);
            document.getElementById('tryForMonson').addEventListener('click', toggleMonson);

            window.addEventListener('resize', onWindowResize, false);

            // Global error handling
            window.addEventListener('error', function(event) {
                console.error('Error occurred: ', event.error);
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const loadingIndicator = document.getElementById('loadingIndicator');
                loadingIndicator.style.display = 'block';

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const contents = e.target.result;
                        const geometry = stlLoader.parse(contents);
                        if (mesh) {
                            scene.remove(mesh);
                        }
                        if (monsonSphere) {
                            scene.remove(monsonSphere);
                            monsonSphere = null;
                        }
                        if (centerSphere) {
                            scene.remove(centerSphere);
                            centerSphere = null;
                        }
                        mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xff69b4 })); // Pink color
                        scene.add(mesh);
                        
                        centerModel();
                        showButtons();
                    } catch (error) {
                        console.error('Error loading model: ', error);
                    } finally {
                        loadingIndicator.style.display = 'none';
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function showButtons() {
            const buttons = document.querySelectorAll('#toolbar button.hidden');
            buttons.forEach(button => {
                button.classList.remove('hidden');
            });
        }

        function setView(view) {
            const currentPosition = camera.position.clone();
            const distance = currentPosition.length();

            switch (view) {
                case 'top':
                    camera.position.set(0, distance, 0);
                    break;
                case 'right':
                    camera.position.set(distance, 0, 0);
                    break;
                case 'left':
                    camera.position.set(-distance, 0, 0);
                    break;
                case 'bottom':
                    camera.position.set(0, -distance, 0);
                    break;
                case 'front':
                    camera.position.set(0, 0, distance);
                    break;
                case 'back':
                    camera.position.set(0, 0, -distance);
                    break;
            }
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function centerModel() {
            if (mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                mesh.position.sub(center);

                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                const cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

                camera.position.set(cameraZ, cameraZ, cameraZ);
                camera.near = maxDim / 100;
                camera.far = maxDim * 100;
                camera.updateProjectionMatrix();

                controls.maxDistance = maxDim * X;
                controls.minDistance = maxDim / X;
                controls.target.copy(center);
                controls.update();

                // Add fog to the scene
                scene.fog = new THREE.FogExp2(0x333333, 0.0025 / X);

                // Adjust grid size
                scene.remove(scene.getObjectByName('gridHelper'));
                const gridHelper = new THREE.GridHelper(maxDim * X * 1.1, 10, 0x333333, 0x333333);
                gridHelper.name = 'gridHelper';
                scene.add(gridHelper);
            }
        }

        function toggleMonson() {
            const button = document.getElementById('tryForMonson');
            const radiusLabel = document.getElementById('radiusLabel');
            if (monsonSphere && centerSphere) {
                scene.remove(monsonSphere);
                scene.remove(centerSphere);
                monsonSphere = null;
                centerSphere = null;
                button.textContent = "Try for Monson";
                radiusLabel.style.display = 'none';
            } else {
                tryForMonson();
                button.textContent = "Remove Monson";
            }
        }

        function tryForMonson() {
            if (mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                // Calculate the radius of the Monson sphere
                const radius = size.length() / 2;

                // Create the Monson sphere with wireframe
                const sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);
                const wireframe = new THREE.WireframeGeometry(sphereGeometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
                monsonSphere = new THREE.LineSegments(wireframe, lineMaterial);

                // Position the Monson sphere so that it touches the top of the model
                monsonSphere.position.set(center.x, box.max.y + radius, center.z);
                scene.add(monsonSphere);

                // Create a small red sphere at the center of the Monson sphere
                const centerSphereGeometry = new THREE.SphereGeometry(radius * 0.1, 8, 8);
                const centerSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                centerSphere = new THREE.Mesh(centerSphereGeometry, centerSphereMaterial);

                centerSphere.position.copy(monsonSphere.position);
                scene.add(centerSphere);

                // Display the radius
                const radiusLabel = document.getElementById('radiusLabel');
                radiusLabel.textContent = `Radius: ${(radius * 2).toFixed(2)} mm`;
                radiusLabel.style.display = 'block';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / (window.innerHeight - 60);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 60);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
